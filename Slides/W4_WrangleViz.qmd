---
title: "More Wrangling"
subtitle: |
   | R Coding Club 
   | RTG 2660
author: "Dr. Lea Hildebrandt"
date: 2024/02/14
description: "Getting the raw data in a useful format"
format: 
  revealjs:
    smaller: true
    scrollable: true
    slide-number: true
    theme: simple
    chalkboard: true
editor: visual
from: markdown+emoji
---

# More Data Wrangling 

(see worksheet!)

## Warm-up

Who has practiced a bit, and what did you cover?

. . .

Did anyone bring a problem?

`{r} #| echo: false} library(tidyverse)`

```{css}
code.sourceCode {   font-size: 1.4em; }  
div.cell-output-stdout {   font-size: 1.4em; }
```

. . .

If I type this code into the console (and run it), I will get the following error. Why?

```         
library(babynames)  
dat <- summarise(.data = babynames, mean_n = mean(n))  

Error in summarise(.data = babynames, mean_n = mean(n)) :    could not find function "summarise"
```

. . .

Which function(s) would you use to calculate reaction times per subject?

```{r}

data <- df %>% 
  group_by(subject) %>% 
  summarise(rt = mean(raw_data)) %>% 
  ungroup()
```

. . .

How do you merge two data sets?

## Valentines Day!

Let's work with a "romantic" data set today! :D

I found this huge data set on speed dating online, plus it's codebook. Let's check it out.

. . .

First, we need to load the data. For this, there are a variety of functions (also for reading in specialized files). Since it is a basic .csv file, we can use \`read_data()\` (from the tidyverse):

```{r}
#| echo: true

library(tidyverse)
speed_dating <- read_csv("Data/Speed Dating Data.csv")

# check out data structure
str(speed_dating)
```

## Removing irrelevant columns

We have 195 columns, it's hard to understand what they mean and have an overview. Let's have a look at the Codebook and decide which columns we want to keep. What do you find interesting?

. . .

```{r}
#| echo: true

speed_dating2 <- speed_dating %>% 
  select(iid, gender, condtn, wave, round, pid, match, int_corr, age, age_o, dec_o, field_cd, goal, sports, dining, art, attr1_1, sinc1_1, intel1_1, fun1_1, amb1_1, shar1_1, attr1_2, sinc1_2, intel1_2, fun1_2, amb1_2, shar1_2, attr1_3, sinc1_3, intel1_3, fun1_3, amb1_3, shar1_3,  attr7_2, sinc7_2, intel7_2, fun7_2, amb7_2, shar7_2, attr7_3, sinc7_3, intel7_3, fun7_3, amb7_3, shar7_3)

```

## Renaming columns

These column names might not be very helpful to remember what the names stand for. If you want to, try to change the names of a few of these columns!

. . .

You could do that while selecting the columns already, but afterwards also works:

```{r}
#| echo: true

speed_dating2 <- speed_dating2 %>% 
  rename(partner_iid = pid)

```

## Is this data frame in a tidy format?

Tidy data: Data that is easily processed by tidyverse functions (and often the required format for statistical analyses and data visualizations).

Three principles:

-   Each variable has its own column.

-   Each observation has its own row.

-   Each value has its own cell.

. . .

Wide vs. long format data?

-   Wide format: Each participant/animal... has one row, observations per participant are in columns.

-   Long format: Each observation = own row. (Likely several rows per participant: Trials etc.)

::: columns
::: column
| ID  | Time_1 | Time_2 |
|-----|--------|--------|
| a1  | 230    | 310    |
| a2  | 195    | 220    |
| a3  | 245    | 290    |
:::

::: column
| ID  | Time | Value |
|-----|------|-------|
| a1  | 1    | 230   |
| a1  | 2    | 310   |
| a2  | 1    | 195   |
| a3  | 2    | 220   |
| a3  | 1    | 245   |
| a3  | 2    | 290   |
:::
:::

Data often does not come in this format but is rather messy! That's why we wrangle.

Tidy data is in between wide and long (you can always go longer! :D)

## Tidy Data 2

What do you think, which of the following data sets is tidy?

```{r}
table1
#> # A tibble: 6 x 4
#>   country      year  cases population
#>   <chr>       <int>  <int>      <int>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3 Brazil       1999  37737  172006362
#> 4 Brazil       2000  80488  174504898
#> 5 China        1999 212258 1272915272
#> 6 China        2000 213766 1280428583
table2
#> # A tibble: 12 x 4
#>   country      year type           count
#>   <chr>       <int> <chr>          <int>
#> 1 Afghanistan  1999 cases            745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000 cases           2666
#> 4 Afghanistan  2000 population  20595360
#> 5 Brazil       1999 cases          37737
#> 6 Brazil       1999 population 172006362
#> # … with 6 more rows
table3
#> # A tibble: 6 x 3
#>   country      year rate             
#> * <chr>       <int> <chr>            
#> 1 Afghanistan  1999 745/19987071     
#> 2 Afghanistan  2000 2666/20595360    
#> 3 Brazil       1999 37737/172006362  
#> 4 Brazil       2000 80488/174504898  
#> 5 China        1999 212258/1272915272
#> 6 China        2000 213766/1280428583

left_join(table4a, table4b, by="country", suffix=c("_cases", "_population"))
# A tibble: 3 x 5
#   country     `1999_cases` `2000_cases` `1999_population` `2000_population`
#   <chr>              <int>        <int>             <int>             <int>
# 1 Afghanistan          745         2666          19987071          20595360
# 2 Brazil             37737        80488         172006362         174504898
# 3 China             212258       213766        1272915272        1280428583
```

## Tidying the speed dating data

If you selected columns that represent different time points (e.g. attr1_1 to attr1_3), you'd have repeated measures that you'd want to have in long format. How do you reshape the data?

. . .

```{r}
#| echo: true

sd_long1 <- speed_dating2 %>% 
  pivot_longer(cols = starts_with("attr1"), names_to = "timepoint", values_to = "attractive")

# do it for several columns
sd_long2 <- speed_dating2 %>% 
  pivot_longer(cols = starts_with(c("attr1", "fun1", "intel1", "amb1", "shar1", "sinc1")), names_to = c(".value", "timepoint"),  names_sep = "_")

# or you could do it separately as above and then join the datasets! Good for practicing joins! :)
```

## Calculating the average ratings

We might want to calculate the average of the ratings, e.g. attractiveness across time points.

First of all, unfortunately the ratings are on different scales between waves:

> Waves 6-9: Please rate the importance of the following attributes in a potential date on a scale of 1-10 (1=not at all important, 10=extremely important):
>
> Waves 1-5, 10-21: You have 100 points to distribute among the following attributes -- give more points to those attributes that are more important in a potential date, and fewer points to those attributes that are less important in a potential date.  Total points must equal 100.

Bring these ratings on scales that are somewhat comparable!

. . .

Now calculate the average ratings across time points per speed dater.

We can either do so before bringing it in long format using \`mutate()\` or afterwards using group_by() and summarise().

## Filtering the speed daters

Make a new data frame that only consists of female speed daters! Also filter out those where the partner is older than the speed dater.

## Sort the data frame

Sort the data frame based on the correlation between the interests, from highest to lowest.

## 
