{
  "hash": "6f471232666ad89ef19c0979bf1a436f",
  "result": {
    "markdown": "---\ntitle: \"Data Wrangling\"\nsubtitle: |\n   | R Coding Club \n   | RTG 2660\nauthor: \"Dr. Lea Hildebrandt\"\ndate: 2024/01/23\ndescription: \"Getting the raw data in a useful format\"\nformat: \n  revealjs:\n    smaller: true\n    scrollable: true\n    slide-number: true\n    theme: simple\n    chalkboard: true\neditor: visual\nfrom: markdown+emoji\n---\n\n\n## Data Wrangling?\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n<style type=\"text/css\">\ncode.sourceCode {\n  font-size: 1.4em;\n}\n\ndiv.cell-output-stdout {\n  font-size: 1.4em;\n}\n</style>\n:::\n\n\n\"Preparation\" of the data for analysis: cleaning up variables (outliers, erroneous values, recoding...), changing the structure/format of data frames, merging data sets, calculating new variables, reducing/summarizing variables...\n\n. . .\n\nYou will spend a lot more time wrangling the data than analyzing it!\n\n. . .\n\nYou could do this manually (e.g. in Excel), but this is tedious, error prone & not reproducible! (+ Datasets can be huge!)\n\n. . .\n\nFortunately, it is easy to do in R\n\n## Accessing Variables/Columns\n\nWhen wrangling your data in R, you often want to access/use different columns, e.g. to calculate new ones. There are a number of ways you can do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a small data set for this example:\ntestdata <- data.frame(a = c(1, 2, 3),  # the c() is important!\n                       b = c(\"a\", \"b\", \"c\"),\n                       c = c(4, 5, 6))\n \n## access column a only:\n# Option 1:\ntestdata$a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\n# Option 2:\ntestdata[2:3,\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\ntestdata[, 1:2]  # index the first column (better practice to use the name!)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b\n1 1 a\n2 2 b\n3 3 c\n```\n:::\n\n```{.r .cell-code}\n# this way, you could also access rows:\n# testdata[1:2, ]  # [rows, columns] --> you can leave it empty if you want all\n# 1:10 would mean 1 to and incl 10!\n\n# Option 3 (select is a tidyverse function)\nlibrary(tidyverse)\nselect(testdata, a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a\n1 1\n2 2\n3 3\n```\n:::\n:::\n\n\n::: notes\ndata.frame() = function to create a data.frame, which is what holds a data set! (tibbles..)\n\nc() = function to make a vector. A vector is just like one single column of a data frame: It can hold several values, but all of the same type.\n\nsubsetting: rows, columns --\\> leave empty!\\\nSelect range!\\\nUse either name or index of column!\n\nselect --\\> tidyverse\n:::\n\n## Tidyverse\n\nYou can do all data wrangling in Base R, i.e. without loading any packages. However, there's a neat collection of packages called **tidyverse**, which makes data wrangling even easier!\n\n. . .\n\nBase R:\n\n`output_data1 <- function1(data)`\n\n`output_data2 <- function2(output_data1)`\n\n`output_data3 <- function3(output_data2)`\n\n. . .\n\nOr:\n\n`output_data <- function3(function2(function1(data)))`\n\n. . .\n\nTidyverse:\n\n`output_data <- data %>% function1() %>% function2(.) %>% function3()`\n\n::: aside\n`%>%` is called the *pipe*. It takes the output of whatever happens to its left and \"hands it over\" to the right. There's also a new base-R-pipe: `|>`. It is very similar, but sometimes the functionality differs.\n:::\n\n::: notes\nBe aware, though, that coding in the tidyverse style is very different than in Base R!\n\nBase R is more similar to \"traditional\" programming and other programming languages.\\\nFor example, you could wrap functions, which would then be carried out from the most nested to the outer function:\\\n`output_data <- function3(function2(function1(data)))`\n\n`function1()` will be carried out first, followed by `function2()`, then `function3()` .\n\n. . .\n\nIn the tidyverse, the same would look like this:\n\n`output_data <- data %>% function1() %>% function2() %>% function(3)`\n\n`%>%` is called \"the pipe\" and will \"hand over\" whatever has been done to the next part. In this example, the `data` is handed over to `function1()`, which is then carried out, the result of which is handed over to `function2()` etc.\n\nTidyverse style programming is thus a bit easier to read!\n\nThere's also the new pipe Base R \\|\\>, which is similar to %\\>%.\n:::\n\n## Tidyverse 2\n\n`library(tidyverse)` will load a number of packages, such as *dplyr*, *ggplot2*, *readr*, *forcats*, *tibble* etc., which are all usefuls for data wrangling.\n\nWe will work mainly with functions from the *dplyr* package, but also use *readr* to read in data. We will also use *ggplot2* to visualize data.\n\nThe most important dplyr functions for data wrangling are:\n\n| Function    | Description                                                                                                                 |\n|-------------|-----------------------------------------------------------|\n| select()    | Include or exclude certain columns (variables)                                                                              |\n| filter()    | Include or exclude certain rows (observations)                                                                              |\n| mutate()    | Create new columns (variables)                                                                                              |\n| summarize() | Create new columns that aggregate data/create summary variables for groups of observations (data frame will become smaller) |\n| group_by()  | Organize the rows (observations) into groups                                                                                |\n| arrange()   | Change the order of rows (observations)                                                                                     |\n\n::: notes\nfunction names very self-explanatory!\n:::\n\n## Activity 1: Babynames\n\n1.  Open RStudio and set the working directory, ensure the environment is clean.\n\n2.  Open a new RMarkdown document and save it, e.g. as \"DataWrangling1.Rmd\".\n\n3.  Install the packages \"tidyverse\" and \"babynames\".\n\n4.  Delete the default text in the Rmd file, insert a new code chunk and insert code that loads the packages babynames and tidyverse.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyverse\")\n# install.packages(\"babynames\")\n\nlibrary(babynames)\nlibrary(tidyverse)\n```\n:::\n\n\n::: notes\nload tidyverse last, otherwise functions with same name will be masked from package that is loaded first. Since we often need tidyverse functions, it's safest to load it last!\n:::\n\n## Activity 2: Look at the Data\n\n::: incremental\n1.  Type the word `babynames` into your console pane and press enter. What kind of information do you get?\n\n    -   \"A tibble: 1,924,665 x 5\"\n\n        -   tibble is a format for the data frame\n\n        -   \\~1.9 million rows/observations\n\n        -   5 columns/variables\n\n2.  What kind of columns/variables do we have?\n\n    -   dbl = double/numeric (can take decimals)\n\n    -   chr = character/string (letters or words)\n\n    -   int = integer (cannot take decimales)\n\n    -   (there are also factors = nominal categories (can be words or numbers))\n:::\n\n::: notes\nask first for 1 and 2\n:::\n\n## Activity 3: Your First Plot\n\n1.  In a new code chunk, insert and run the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- babynames %>% \n  filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex==\"F\")\n\nggplot(data = dat,\n       aes(x = year,\n           y = prop, \n           colour = name))+\n  geom_line()  \n```\n\n::: {.cell-output-display}\n![](W2b_DataWranglingR_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\nWe first filter four names, assign this new data to `dat`, and make a linechart using `ggplot()`!\n\n. . .\n\n2.  Change the code to male names (that are hopefully present in the dataset) and change `sex==\"F\"` to `sex==\"M\"`.\n\n# Wrangling Babynames\n\n## Activity 4: Selecting Variables of Interest\n\n1.  In a new code chunk, use `select()` to select only the columns `year`, `sex`, `name`, and `prop` and store it as a new tibble called `babynames_reduced`. Remember that you can run `?select` in the console if you need help, e.g. regarding the input/arguments to the function.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames_reduced <- select(.data = babynames, year, sex, name, prop)\n\n# or alternatively:\nbabynames_reduced <- babynames %>% \n  select(year, sex, name, prop)\n\n# or alternatively:\nbabynames_reduced <- babynames %>% \n  select(-n) # remove using -\n```\n:::\n\n\n## Activity 5: Arranging Data\n\nChange the order of the data (oberservations/rows)!\n\n::: incremental\n1.  Using `arrange()`, try sorting the data according to the `names` column.\n    1.  What happens?\n2.  How can you sort a column in a descending fashion? Check out the help file (`?arrange`).\n:::\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort_asc <- arrange(.data = babynames,\n                    name)\n\n\nsort_desc <- arrange(babynames, \n                     desc(year)) \n```\n:::\n\n\n::: notes\nremember to save data in new tibble/data frame!\n:::\n\n## Activity 6: Filter Observations\n\nWe have already used `select()` to keep only certain variables, but often we also want to keep only certain observations, e.g. babies born after 1999 (or reaction times that are realistic, not too fast and not too slow, or certain conditions).\n\nWe use the function `filter()` for this.\n\n. . .\n\nLook at the following code and think about what it might do.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilt1 <- filter(.data = babynames,\n                year > 2000)\n```\n:::\n\n\n## Detour: Boolean Expressions\n\nThe second argument, `year > 2000`, is a Boolean or logical expression, which means that it results in a value of either TRUE or FALSE. `filter()` runs this expression and then removes all values/rows that contain FALSE.\n\nThere are also other Boolean expressions:\n\n| Operator | Name                  | is TRUE if and only if                    |\n|----------------|-------------------|-------------------------------------|\n| A \\< B   | less than             | A is less than B                          |\n| A \\<= B  | less than or equal    | A is less than or equal to B              |\n| A \\> B   | greater than          | A is greater than B                       |\n| A \\>= B  | greater than or equal | A is greater than or equal to B           |\n| A == B   | equivalence           | A exactly equals B                        |\n| A != B   | not equal             | A does not exactly equal B                |\n| A %in% B | in                    | A is an element of [vector]{.underline} B |\n\n: Boolean expressions\n\n## Activity 6b: Filter some more\n\n::: incremental\n1.  Keep only those observations with the name \"Mary\".\n2.  Discard all \"Mary\"'s and keep only observations from year \\> 2000.\n3.  Keep only those with names of former Queens (Mary, Elizabeth, Victoria).\n4.  Discard the ones with the Queen names!\n:::\n\n. . .\n\nFirst task:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarys <- filter(babynames, name == \"Mary\")\n```\n:::\n\n\n. . .\n\nThe second task might be difficult because you have two expressions, `name != \"Mary\"` and `year > 2000`. You can simply add several expressions separated by comma's in filter:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_marys_young <- filter(babynames, name != \"Mary\", year > 2000)\n```\n:::\n\n\n. . .\n\nThird task:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqueens <- filter(babynames, name %in% c(\"Mary\", \"Elizabeth\", \"Victoria\"))\n```\n:::\n\n\n. . .\n\nThe fourth task is a bit tricky! You could use three filters in a row with `name!=\"Mary\"` (or \"Elizabeth\" or \"Victoria\"). Or you could use %in%, but then you can't use the `!` in front of the `%in%`. An alternative to negate the whole expression with `!`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_queens <- filter(babynames, \n                    !(name %in% c(\"Mary\",\n                                  \"Elizabeth\",\n                                  \"Victoria\")))\n```\n:::\n\n\n## Activity 7: Create New Variables\n\nIf we want to create variables that do not exist yet (i.e. by calculating values, combining other variables etc.), we can use `mutate()`!\n\n1.  Add a variable called \"country\" that contains the value \"USA\" for all observations\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaby_where <- mutate(.data = babynames,\n                  country = \"USA\")\n```\n:::\n\n\n. . .\n\nBut mutate is much more powerful and can create variables that differ per observation, depending on other values in the tibble/data frame:\n\n2.  Create a variable that denotes the decade a baby was born:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaby_decades <- mutate(.data = babynames,\n                  decade = floor(year/10) *10)\n\nhead(baby_decades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year sex   name          n   prop decade\n  <dbl> <chr> <chr>     <int>  <dbl>  <dbl>\n1  1880 F     Mary       7065 0.0724   1880\n2  1880 F     Anna       2604 0.0267   1880\n3  1880 F     Emma       2003 0.0205   1880\n4  1880 F     Elizabeth  1939 0.0199   1880\n5  1880 F     Minnie     1746 0.0179   1880\n6  1880 F     Margaret   1578 0.0162   1880\n```\n:::\n:::\n\n\nWhat happens here?\n\n## Activity 8: Summarizing\n\nThe goal of data wrangling is often to summarize (or aggregate) the data, e.g. to have an average value per condition. Sometimes you'd also want to calculate descriptive statistics to report.\n\n. . .\n\nYou can do so using the function `summarise()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# run the filter function just like above again:\ndat <- babynames %>% \n  filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex == \"F\")\n\n# summarize the data, calculating the number of oberservations:\ndat_sum <- summarise(.data = dat,\n                     total = sum(n))\ndat_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n    total\n    <int>\n1 2161374\n```\n:::\n:::\n\n\nAs you can see, a new variable named total is created, which contains the total number of observations. There's also just one row in the data frame, because summarise() reduces the data frame (to only include the necessary information)!\n\n## Activity 8: Grouping and Summarizing\n\nOften, we want to summarize data for specific subgroups, e.g. conditions. For this aim, we use `summarise()` together with `group_by()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_dat <- group_by(.data = dat,\n                      name) \n```\n:::\n\n\n`group_dat` now doesn't look much different than `dat`, but the grouping - based on the names, so each name is now a category - is saved in the data frame! (Type `group_dat` in the console and you will see #Groups: name\\[4\\])\n\nIf you now run the summarize() code from before (but with `group_dat` as input), you will not get the total number of observations, but the observations per name!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_sum <- summarise(.data = group_dat, \n                       total = sum(n)) \ngroup_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name       total\n  <chr>      <int>\n1 Alexandra 231364\n2 Beverly   376914\n3 Emily     841491\n4 Kathleen  711605\n```\n:::\n:::\n\n\n## Activity 8b: Grouping and Summarizing 2\n\nYou can group by several columns (think of crosstables) and add several columns at once to the data (e.g. doing different calculations - same for `mutate()`!)\n\n1.  Use the `baby_decades` data frame and `group_by()` sex & decade. Save the output to a new data frame/tibble\n2.  Use that tibble to calculate the mean and median number of observations.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_decades <- group_by(baby_decades, \n                          sex, \n                          decade)\n\nsum_decades <- summarise(group_decades,\n                         mean_year = mean(n),\n                         median_year = median(n))\n```\n:::\n\n\n## Pipes\n\nRemember the pipe `%>%`? So far we have always saved intermediate steps in tibbles and used those as input for the next function. With the pipe, we can chain several functions and save relevant results only, no need for crowding the Environment with intermediate tibbles!\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_summary <- babynames %>%\n  mutate(decade = floor(year/10) *10) %>%\n  filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex==\"F\") %>%\n  group_by(name, \n           decade) %>%\n  summarise(mean_decade = mean(n))\n```\n:::\n\n\n## Counting Data\n\nThere are several ways to get the number of observations per group. In the tidyverse style, one is to use (`group_by()` +) `summarise()` with the function `n()`. The other, a shortcut, is to use `count()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames %>% \n   filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex==\"F\") %>%\n  group_by(name) %>% \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name          n\n  <chr>     <int>\n1 Alexandra   117\n2 Beverly     122\n3 Emily       138\n4 Kathleen    138\n```\n:::\n\n```{.r .cell-code}\nbabynames %>%\n  filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex==\"F\") %>%\n  count(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name          n\n  <chr>     <int>\n1 Alexandra   117\n2 Beverly     122\n3 Emily       138\n4 Kathleen    138\n```\n:::\n:::\n\n\n## Ungrouping\n\nRemember that the grouping done with `group_by()` is saved with the data frame (even though it might not immediately be obvious).\n\nIt is good practice to always `ungroup()` your data once you finished the operations you needed the grouping for!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"8\"}\nbabynames %>% \n   filter(name %in% c(\"Emily\",\n                     \"Kathleen\",\n                     \"Alexandra\",\n                     \"Beverly\"), sex==\"F\") %>%\n  group_by(name) %>% \n  summarise(n = n()) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name          n\n  <chr>     <int>\n1 Alexandra   117\n2 Beverly     122\n3 Emily       138\n4 Kathleen    138\n```\n:::\n:::\n\n\n# Data Wrangling 3\n\n::: notes\nData Wrangling 2? More exercises! Homework! :)\n:::\n\n## Tidy Data\n\nTidy data: Data that is easily processed by tidyverse functions (and often the required format for statistical analyses and data visualizations).\n\nThree principles:\n\n-   Each variable has its own column.\n\n-   Each observation has its own row.\n\n-   Each value has its own cell.\n\n. . .\n\nWide vs. long format data?\n\n-   Wide format: Each participant/animal... has one row, observations per participant are in columns.\n\n-   Long format: Each observation = own row. (Likely several rows per participant: Trials etc.)\n\n::: columns\n::: column\n| ID  | Time_1 | Time_2 |\n|-----|--------|--------|\n| a1  | 230    | 310    |\n| a2  | 195    | 220    |\n| a3  | 245    | 290    |\n:::\n\n::: column\n| ID  | Time | Value |\n|-----|------|-------|\n| a1  | 1    | 230   |\n| a1  | 2    | 310   |\n| a2  | 1    | 195   |\n| a3  | 2    | 220   |\n| a3  | 1    | 245   |\n| a3  | 2    | 290   |\n:::\n:::\n\n::: notes\nData often does not come in this format but is rather messy! That's why we wrangle.\n\nTidy data is in between wide and long (you can always go longer! :D)\n:::\n\n## Tidy Data 2\n\nWhat do you think, which of the following data sets is tidy?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  country     `1999_cases` `2000_cases` `1999_population` `2000_population`\n  <chr>              <dbl>        <dbl>             <dbl>             <dbl>\n1 Afghanistan          745         2666          19987071          20595360\n2 Brazil             37737        80488         172006362         174504898\n3 China             212258       213766        1272915272        1280428583\n```\n:::\n:::\n\n\n::: notes\nTable1 is tidy!\n:::\n\n## Analyzing the Autism Spectrum Quotient\n\nFor the following activities, we will need the following files:\n\n-   [responses.csv](https://psyteachr.github.io/quant-fun-v2/responses.csv) containing the AQ survey responses to each of the 10 questions for the 66 participants\n\n-   [qformats.csv](https://psyteachr.github.io/quant-fun-v2/qformats.csv) containing information on how a question should be coded - i.e. forward or reverse coding\n\n-   [scoring.csv](https://psyteachr.github.io/quant-fun-v2/scoring.csv) containing information on how many points a specific response should get; depending on whether it is forward or reverse coded\n\n-   [pinfo.csv](https://psyteachr.github.io/quant-fun-v2/pinfo.csv) containing participant information such as `Age`, `Sex` and importantly `ID` number.\n\n## Set Up\n\n1.  Clear your environment or restart the R session (Session -\\> Restart R).\n\n2.  Start a new section (# Data Wrangling 3) in your Rmd document.\n\n3.  Make sure you have downloaded the data into your working directory (or set your working directory to the class folder with the data).\n\n## Load the Data\n\nLoad the four .csv files into your environment, e.g.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponses <- read_csv(\"responses.csv\") \nqformats <-                 # load in question formats\nscoring <-                  # load in scoring info\npinfo <-                    # load in participant information\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Look at the Data\n\nIs the data (`responses`) in a tidy format?\n\n. . .\n\nWhy is it not tidy?\n\n::: notes\nwide format\n:::\n\n## Reformatting the Data\n\nLet's bring the wide data in a longer, tidy format!\n\n. . .\n\nThere are several functions in R to reformat data, but the newest ones are `pivot_longer()` and `pivot_wider()`.\n\nRun the code and see what changes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlong <- pivot_longer(data = responses,\n                      cols = Q1:Q10,\n                      names_to = \"Question\", \n                      values_to = \"Response\")\n```\n:::\n\n\n. . .\n\nDescribe what the function does, what does the input/the arguments mean?\n\n## Joining the Data\n\nWe now want to combine the different data sets: We want to have the information how the questionnaire has to be scored included with the items.\n\nWe can find the scoring information (i.e. how the questions are framed, positive or negative/whether they need to be reversed) in the `qformats` tibble. Furthermore, we can find how many points are given to each item/response in `scoring`.\n\nWe can use the function `inner_join()` to merge the tibbles.\n\n. . .\n\nActivity: Replace the `NULL` values in the below code with the necessary variable names to join `rlong` and `qformats` by `Question`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlong2 <- inner_join(x = NULL, \n                     y = NULL, \n                     by = \"NULL\")\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlong2 <- inner_join(x = rlong, \n                     y = qformats, \n                     by = \"Question\")\n```\n:::\n\n\n::: notes\nDescribe what happened?\n\nwhat is forward and reverse scoring?\n:::\n\n## Combining more Data\n\nYou can only join two data frames/tibbles at once.\\\nNow add the scoring data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrscores <- inner_join(rlong2, \n                      scoring, \n                      c(\"QFormat\", \"Response\"))\n```\n:::\n\n\n## Calculate the Questionnaire Scores\n\nHow do we need to group and summarize the data to get a sum score per person? (Ignoring the reverse coding for now!) Add the correct column names instead of the `NULL`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naq_scores <- rscores %>% \n             group_by(NULL) %>%\n             summarise(AQ = sum(NULL))\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\naq_scores <- rscores %>% \n             group_by(Id) %>% # group by the ID number in column Id\n             summarise(AQ = sum(Score)) # sum column Score to obtain AQ scores.\n```\n:::\n\n\n## Pipe it all together!\n\n\n::: {.cell}\n\n```{.r .cell-code}\naq_scores2 <- responses %>% \n  pivot_longer(cols = Q1:Q10,\n               names_to = \"Question\", \n               values_to = \"Response\") %>%  \n  inner_join(qformats, \"Question\") %>% \n  inner_join(scoring, c(\"QFormat\", \"Response\")) %>% \n  group_by(Id) %>% \n  summarise(AQ = sum(Score)) \n```\n:::\n\n\n# Data Wrangling 2\n\n## Learning to Wrangle\n\nIn a Breakout-session (or as **homework**), work in small groups on the assignments (Activity 1 - Activity 8) in this chapter: <https://psyteachr.github.io/quant-fun-v2/data-wrangling-2.html>\n\n## Solutions\n\nWe'll use data from a [paper](https://journals.sagepub.com/doi/full/10.1177/0956797617730892) that investigates whether the ability to perform an action influences perception. In particular, the authors wondered whether participants who played Pong would perceive the ball to move faster when they have a small paddle.\n\n::: incremental\n1.  Download the data, set the working directory, clean your environment. Open a new R Markdown file and save it as \"DataWrangling2.Rmd\". Delete the text in the document.\n\n2.  Add a new code chunk and read in the data.\n\n3.  Look at the data.\n:::\n\n## Solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\")\npong_data <- read_csv(\"Data/PongBlueRedBack 1-16 Codebook.csv\")\nsummary(pong_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Participant     JudgedSpeed      PaddleLength   BallSpeed    TrialNumber    \n Min.   : 1.00   Min.   :0.0000   Min.   : 50   Min.   :2.0   Min.   :  1.00  \n 1st Qu.: 4.75   1st Qu.:0.0000   1st Qu.: 50   1st Qu.:3.0   1st Qu.: 72.75  \n Median : 8.50   Median :1.0000   Median :150   Median :4.5   Median :144.50  \n Mean   : 8.50   Mean   :0.5471   Mean   :150   Mean   :4.5   Mean   :144.50  \n 3rd Qu.:12.25   3rd Qu.:1.0000   3rd Qu.:250   3rd Qu.:6.0   3rd Qu.:216.25  \n Max.   :16.00   Max.   :1.0000   Max.   :250   Max.   :7.0   Max.   :288.00  \n BackgroundColor      HitOrMiss       BlockNumber   \n Length:4608        Min.   :0.0000   Min.   : 1.00  \n Class :character   1st Qu.:0.0000   1st Qu.: 3.75  \n Mode  :character   Median :1.0000   Median : 6.50  \n                    Mean   :0.6866   Mean   : 6.50  \n                    3rd Qu.:1.0000   3rd Qu.: 9.25  \n                    Max.   :1.0000   Max.   :12.00  \n```\n:::\n\n```{.r .cell-code}\n# look at the data (can also use summary(), str(), head() etc.)\nglimpse(pong_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 4,608\nColumns: 8\n$ Participant     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ JudgedSpeed     <dbl> 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, …\n$ PaddleLength    <dbl> 50, 250, 50, 250, 250, 50, 250, 50, 250, 50, 50, 250, …\n$ BallSpeed       <dbl> 5, 3, 4, 3, 7, 5, 6, 2, 4, 4, 7, 7, 3, 6, 5, 7, 2, 5, …\n$ TrialNumber     <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ BackgroundColor <chr> \"red\", \"blue\", \"red\", \"red\", \"blue\", \"blue\", \"red\", \"r…\n$ HitOrMiss       <dbl> 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, …\n$ BlockNumber     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n```\n:::\n\n```{.r .cell-code}\nnew_pong_data <- pong_data %>% \n  select(BallSpeed, HitOrMiss, JudgedSpeed, Participant, \n         TrialNumber) %>% \n  arrange(desc(HitOrMiss), desc(JudgedSpeed)) %>% \n  filter(JudgedSpeed == 1,\n         BallSpeed %in% c(\"2\", \"4\", \"5\", \"7\"),\n         HitOrMiss == 0) %>% \n  filter(TrialNumber > 2) %>% \n  mutate(TrialNumber = TrialNumber -1) \n  \n  # summarize (use old data frame because we removed variables)\npong_data_hits <- pong_data %>% \n  group_by(BackgroundColor, \n           PaddleLength) %>% \n  summarise(total_hits = sum(HitOrMiss, \n                             na.rm = TRUE),\n            meanhits = mean(HitOrMiss, \n                            na.rm = TRUE))\n```\n:::\n\n\n## Thanks!\n\nLearning objectives:\n\n-   Learn about tidyverse vs. base R\n\n-   Learn and apply the six basic dplyr \"verbs\"\n\n-   Learn how to join data frames\n\n. . .\n\nNext week:\n\nData Visualization in R\n\n",
    "supporting": [
      "W2b_DataWranglingR_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}