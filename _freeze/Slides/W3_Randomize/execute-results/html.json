{
  "hash": "2fefda26bda440172c581be2c71ca377",
  "result": {
    "markdown": "---\ntitle: \"Randomization and Counterbalancing\"\nsubtitle: |\n   | R Coding Club \n   | RTG 2660\nauthor: \"Dr. Lea Hildebrandt\"\ndate: 2024/02/06\ndescription: \"Using R for e.g. your study design\"\nformat: \n  revealjs:\n    smaller: true\n    scrollable: true\n    slide-number: true\n    theme: simple\n    chalkboard: true\neditor: visual\nfrom: markdown+emoji\n---\n\n\n# Randomization vs. Counterbalancing\n\n\n::: {.cell}\n<style type=\"text/css\">\ncode.sourceCode {\n  font-size: 1.4em;\n}\n\ndiv.cell-output-stdout {\n  font-size: 1.4em;\n}\n</style>\n:::\n\n\n*Randomization/random assignment*: Determining completely at random (or pseudorandom) e.g. which condition a participant belongs to/which stimulus is shown... (Block randomization = all conditions occur once before being repeated.)\n\n*Counterbalancing*: Determining how many conditions etc. there are and making sure that all orders are seen by the same number of participants. (This term is often used for within-subjects designs!)\n\n::: notes\nProblem Random: unequal sample sizes (not a problem for LMMs, but should be roughly equal to have good power)\n\nCounterbalanced Randomization: Make list and randomly assign participants to which list to use.\n:::\n\n## Let's dive in with an example\n\nWe have three conditions (between-subject) and we want to randomly assign each participant to a condition.\n\nWhat kind of function would you need for this?\n\n. . .\n\nWe would use a function called `sample()`, which will be our best friend for today:\\\nIt allows us to draw from a vector (think of drawing a paper slip from a hat), either with or without replacement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# good practice to set a seed to make the (pseudo-)randomization reproducible \nset.seed(123)\n\n# just shuffle\n# you could also use this to create different stimulus-lists!\nconds <- sample(c(\"condition A\", \"condition B\", \"condition C\"))\nconds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"condition C\" \"condition A\" \"condition B\"\n```\n:::\n\n```{.r .cell-code}\n# draw them repeatedly (with equal probability)\nconds2 <- sample(c(\"condition A\", \"condition B\", \"condition C\"), 30, replace = TRUE)\nconds2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"condition B\" \"condition C\" \"condition B\" \"condition B\" \"condition B\"\n [6] \"condition C\" \"condition A\" \"condition B\" \"condition B\" \"condition A\"\n[11] \"condition B\" \"condition C\" \"condition A\" \"condition C\" \"condition C\"\n[16] \"condition A\" \"condition A\" \"condition A\" \"condition A\" \"condition C\"\n[21] \"condition B\" \"condition C\" \"condition B\" \"condition A\" \"condition B\"\n[26] \"condition C\" \"condition B\" \"condition A\" \"condition C\" \"condition C\"\n```\n:::\n\n```{.r .cell-code}\ntable(conds2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nconds2\ncondition A condition B condition C \n          9          11          10 \n```\n:::\n:::\n\n\n. . .\n\nThe latter would be \\~ random assignment. If we want equal group sizes, we could use a vector of length = sample size and shuffle it (sample without replacement):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconds <- sample(rep(c(\"condition A\", \"condition B\", \"condition C\"), times=10))\n# conds\ntable(conds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nconds\ncondition A condition B condition C \n         10          10          10 \n```\n:::\n:::\n\n\nAdd to dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndesign <- tibble(\n  ID = 1:30,\n  cond = sample(rep(c(\"condition A\", \"condition B\", \"condition C\"), times=10))\n)\n```\n:::\n\n\n## Two conditions\n\nWe can draw them separately:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment <- c(\"Treatment\", \"Control\")\ncolor <- c(\"blue\", \"yellow\")\n\ndesign <- tibble(\n  ID = 1:40,\n  cond = sample(rep(treatment, times=20)),\n  color = sample(rep(color, times=20))\n)\n\ntable(design$cond, design$color) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           \n            blue yellow\n  Control      9     11\n  Treatment   11      9\n```\n:::\n:::\n\n\n. . .\n\n...or make sure that every combination is equally often represented:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2-3|4|5|6\"}\ndesign <- crossing(treatment, color) %>% # gets all combinations\n  mutate(combi=str_c(treatment, color, sep=\"_\")) %>%  # combine columns\n  select(-treatment, -color) %>%   # remove original ones\n  reframe(combi2 = sample(rep(combi, 10))) %>%  # use reframe to add rows\n  mutate(ID = 1:n()) %>%  # add participant number\n  separate_wider_delim(combi2, delim=\"_\", names=c(\"treatment\", \"color\"))\n\ntable(design$treatment, design$color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           \n            blue yellow\n  Control     10     10\n  Treatment   10     10\n```\n:::\n:::\n\n\n## Draw from a probability distribution\n\nSometimes it can be helpful to draw a random number from a certain probability distribution, e.g. if you want to get Inter-Trial-Intervals from a normal or uniform distribution or if you want to simulate a coin toss with a binomial distribution.\n\nIn R, you can use certain functions that start with an \"r\" (e.g. `rnorm()`, `runif()`, `rbinom()`) to draw random numbers from distributions.\n\n. . .\n\nLet's start with the coin toss, as it is similar to using `sample()`. The binomial distribution gives you the \"successes\" (vs. failure, so 1 vs. 0 or heads vs. tails) in a row of \"experiments\" (coin tosses).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# repeat a study 10 times in which 100 fair coins are tossed -out of the 100, how often do we get heads?\nrbinom(10,100,.5) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 51 41 51 44 43 46 43 48 51 41\n```\n:::\n:::\n\n\nYou could of course determine the condition by \"tossing a coin\". The \"problem\" is that the count of each outcome will be different for each participant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For one participant, determine whether 10 trials are condition 0 or 1 (with 60% probability for cond. 1)\nrbinom(10,1,.6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 0 1 1 0 1 1 0 0\n```\n:::\n:::\n\n\n. . .\n\nLet's draw 10 jittered ITIs from a normal distribution: We want them to be jittered around a mean of 1500 msec with a SD of 200 msec:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(10, mean = 1500, sd = 200)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1387.146 1694.062 1496.273 1572.474 1902.261 1264.407 1348.966 1433.743\n [9] 1443.259 1562.831\n```\n:::\n\n```{.r .cell-code}\n# you could also round them:\nround(rnorm(10, 1500, 200), 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1869 1304 1939 1459 1695 1326 1400 1657 1080 1492\n```\n:::\n:::\n\n\nYou could use the uniform distribution if you want each number to be equally likely:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get 10 numbers between 1200 and 1800 msec\nround(runif(10, min = 1200, max = 1800), 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1406 1720 1473 1520 1778 1665 1325 1385 1783 1551\n```\n:::\n:::\n\n\n## Any other questions?\n\nSpecific to your design etc.?\n\n## Ecem's study - detour incl. loops and if-statements!\n\n-   Shape (4x) and color (4x)\n\n-   each participant (N=~~16~~ 4) should have four stimuli assigned, each color and each shape once\n\n-   but each of the stimuli should be used equally often (= once)!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshape <- c(\"s1\", \"s2\", \"s3\", \"s4\")\ncolor <- c(\"c1\", \"c2\", \"c3\", \"c4\")\n\ncrossing(shape, color)  # 16 combinations\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 2\n   shape color\n   <chr> <chr>\n 1 s1    c1   \n 2 s1    c2   \n 3 s1    c3   \n 4 s1    c4   \n 5 s2    c1   \n 6 s2    c2   \n 7 s2    c3   \n 8 s2    c4   \n 9 s3    c1   \n10 s3    c2   \n11 s3    c3   \n12 s3    c4   \n13 s4    c1   \n14 s4    c2   \n15 s4    c3   \n16 s4    c4   \n```\n:::\n:::\n\n\nIf we simply draw from this list, a participant likely has a shape/color twice. If we draw from both lists separately, we can't make sure that another participant won't get the same combination! (If we just draw stimuli completely at random, this would be fine...)\n\n. . .\n\n**Task: In small groups, try to solve this problem in pseudo-code (break it down in small steps and write down what should happen in each step). (10 min.!)**\n\n## Get stimulus list\n\nWe could \"brute-force\" it: Draw a stimulus and compare it to the already drawn ones. If already included, discard and draw next one etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# participant 1\nstimlist1 <- tibble(\n  ID = 1, \n  stim_shape = sample(shape),\n  stim_col = sample(color)\n) %>% \n  mutate(combi=str_c(stim_shape, stim_col, sep=\"_\"))   # combine columns\n  \n# participant 2\nstimlist2 <- tibble(\n  ID = 2, \n  stim_shape = sample(shape),\n  stim_col = sample(color)\n) %>% \n  mutate(combi=str_c(stim_shape, stim_col, sep=\"_\"))   # combine columns\n\n# check whether stimuli are the same in both stimlists\n# you could use %in% (not \"==\" -> would only check rowwise!) or setdiff()\n\nstimlist1$combi %in% stimlist2$combi # checks whether any of stimlist 2 is in stimlist 1 -> should be 4x FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nsetdiff(stimlist2$combi, stimlist1$combi) # gives you the ones that are different in stimlist2 -> should be 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"s3_c3\" \"s4_c4\" \"s1_c2\" \"s2_c1\"\n```\n:::\n\n```{.r .cell-code}\nany(stimlist1$combi %in% stimlist2$combi) # test whether any of the 4 is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Run repeatedly until \"novel\" list is found\n\nWe will use a `while statement`[^1] in combination with an `if statement` for this!\n\n[^1]: Rarely used in tidyverse, but often used in base R/other programming languages!\n\nThe `while statement` will run the code until the condition in the if statement is met and then break out of the while loop.\n\nThe `if statement` tests a condition. Only if the condition is met, the code underneath is carried out. It is also possible to use alternative conditions: `if(...) {...} elseif() {...} else {...}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check repeatedly\nwhile(TRUE) {\n  stimlist2 <- tibble(\n  ID = 2, \n  stim_shape = sample(shape),\n  stim_col = sample(color)\n) %>% \n  mutate(combi=str_c(stim_shape, stim_col, sep=\"_\"))   # combine columns\n  \n  if(!any(stimlist1$combi %in% stimlist2$combi)){\n    break;\n  }\n}\n\n# we could also use:\n# test <- TRUE\n# while(test == TRUE) {\n#   ...\n#   if(...)\n#     test <- FALSE}\n```\n:::\n\n\n## Repeat for more participants\n\nWe could copy the code for every participant, but this would be tedious and would result in a long script. Alternatively, we can use a `for-loop`! It is similar to the while statement and runs the included code a specified number of times:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-4|5-12|14|16,24|17-21|23|28-29|43-48\"}\n# initiate variables and dataframes (fill in with values later)\nn <- 4 # easily change number of subjects here - max 4 possible w/16 combis!\nshape <- c(\"heart\", \"sacral\", \"throat\", \"solar\") # or \"s1\" etc\ncolor <- c(\"yellow\", \"purple\", \"orange\", \"blue\") # or \"c1\" etc\n\n# initiate \"empty\" tibble to fill in for-loop\noverall_stimlist <- tibble(\n  ID = rep(NA, 4*n), # fill in NAs, 4 rows per participant\n  stim_shape = rep(NA, 4*n),\n  stim_col = rep(NA, 4*n),\n  combi = rep(NA, 4*n)\n)\n\nfor(i in 1:n){\n  \n  while(TRUE) {\n  stimlist2 <- tibble(\n    ID = i,   # use the index of the loop iteration!\n    stim_shape = sample(shape),\n    stim_col = sample(color)) %>% \n    mutate(combi=str_c(stim_shape, stim_col, sep=\"_\"))   # combine columns\n  \n  if(!any(overall_stimlist$combi %in% stimlist2$combi)){\n      break;\n    }\n  }\n  \n   # save to overall_stimlist at correct location\n  overall_stimlist[(4*i-3):(4*i), ] <- stimlist2\n  \n  \n  # Ecem also wants to shuffle each stimlist2 4 times to get different orders - making sure that no stimulus is in the same location!\n  # we can get all permutations (using an R function like Permn()), but this would be 24 variations (incl. same stimulus in same location)\n  # instead, we just manually shift the stimuli by one (e.g. 1st becomes 2nd etc.)\n  \n  # stimlist3 <- stimlist2[c(2,3,4,1),]\n  # stimlist4 <- stimlist2[c(3,4,1,2),]\n  # stimlist5 <- stimlist2[c(4,1,2,3),]\n \n  \n}\n\n# add further info to the dataframe\noverall_stimlist <- overall_stimlist %>% \n  mutate(\n    CS_type = rep(c(\"threat\", \"safety\", \"amb1\", \"amb2\"), times=n),\n    percentage = rep(c(100, 0, 50, 50), times=n)\n  )\n```\n:::\n\n\nFor Ecem's study, it is more complex and she already made stimulus lists per hand! I would actually just use this list and read it into R (in a good format).\n\n## Make the trial list per participant\n\nNow that we know which stimulus is used for which category for each participant, we can generate the stimulus list. In Ecem's study, we have 2 blocks à 100 trials (after the first block, the stimulus type changes). Let's focus on the first block.\n\nWe have different trial types: 60 single- and 40 multi-cue. For the single cues, each of the 4 stimulus types is shown 15x, for the multi-cue, a combination of two types (threat or safety with each amb) is shown 10x. In the multi-cue trials, other stimuli are also shown, which are the other combinations of shape and color.\n\n**Task: How can we make an individual trial list per subject (i.e. an order of trials)? (2 min.)**\n\n. . .\n\nWe first simply list all possibilities and repeat them as often as needed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial_list <- sample(c(  # wrap in sample()!\n                       rep(c(\"threat\",\"safety\",\"amb1\",\"amb2\"), 15),\n                       rep(c(\"threat-amb1\",\"threat-amb2\",\"safety-amb1\",\"safety-amb2\"), 10)\n                       ))\n\nlength(trial_list)  # make sure it's 100!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n\n```{.r .cell-code}\ntrial_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] \"amb1\"        \"threat-amb1\" \"threat\"      \"amb2\"        \"threat-amb2\"\n  [6] \"safety-amb2\" \"safety-amb2\" \"threat\"      \"safety-amb2\" \"threat\"     \n [11] \"threat\"      \"safety-amb2\" \"safety\"      \"threat\"      \"amb2\"       \n [16] \"amb2\"        \"safety-amb1\" \"amb1\"        \"threat\"      \"amb1\"       \n [21] \"amb1\"        \"safety\"      \"threat-amb1\" \"amb2\"        \"threat-amb2\"\n [26] \"amb2\"        \"threat-amb1\" \"threat\"      \"safety-amb1\" \"threat-amb1\"\n [31] \"safety\"      \"amb2\"        \"safety-amb1\" \"threat\"      \"threat\"     \n [36] \"safety\"      \"safety-amb2\" \"amb1\"        \"threat\"      \"safety\"     \n [41] \"threat\"      \"threat-amb1\" \"amb2\"        \"safety\"      \"safety-amb1\"\n [46] \"safety\"      \"amb1\"        \"threat\"      \"amb2\"        \"safety-amb1\"\n [51] \"safety-amb1\" \"threat-amb2\" \"threat-amb1\" \"safety-amb2\" \"amb1\"       \n [56] \"safety-amb1\" \"safety-amb1\" \"threat\"      \"amb1\"        \"threat-amb2\"\n [61] \"safety\"      \"safety\"      \"amb2\"        \"threat-amb1\" \"safety-amb2\"\n [66] \"amb2\"        \"safety\"      \"threat-amb1\" \"safety-amb1\" \"amb2\"       \n [71] \"amb2\"        \"amb2\"        \"safety-amb2\" \"amb1\"        \"amb1\"       \n [76] \"threat-amb1\" \"threat-amb1\" \"safety-amb2\" \"safety\"      \"amb1\"       \n [81] \"threat-amb2\" \"safety\"      \"safety\"      \"safety\"      \"safety-amb1\"\n [86] \"safety-amb2\" \"amb1\"        \"amb1\"        \"threat-amb2\" \"amb1\"       \n [91] \"threat\"      \"threat\"      \"amb2\"        \"safety\"      \"threat-amb2\"\n [96] \"amb2\"        \"amb1\"        \"threat-amb2\" \"threat-amb2\" \"threat-amb2\"\n```\n:::\n:::\n\n\n## Minimum distance same stimulus types?\n\nWhat if we need a minimum distance between the same stimulus types?\n\nTAKES LONG; DON'T RUN!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial_list2 <- rep(NA, length(trial_list))\ntrial_list2[1] <- trial_list[1] # fill in the first already to have a comparison\n\nfor (i in 2:length(trial_list)) { # start with 2!\n  \n  while(trial_list[i] == trial_list[i-1]) { # check for last 2: %in% trial_list[i-2:i-1]\n    trial_list[i:length(trial_list)] <- sample(trial_list[i:length(trial_list)])\n  } \n  trial_list2[i] <- trial_list[i]\n  \n}\n\n# check whether correct\ntrial_list2 != lag(trial_list2) \n```\n:::\n\n\n## Fill in the remaining information\n\n...for single cue trials!\n\n**Tasks: (5 min.)**\n\n-   **How can we get the further stimulus information (color, shape) into this list?**\n\n-   **How can we add the info whether it's a \"sc\" or a \"mc\" trial**\n\n-   **How can we determine whether a shock should be given in each trial?**\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriallist_vp1 <- tibble(\n  trial = 1:length(trial_list),\n  block = 1,\n  CS_type = trial_list # same name as in stimlist for join!\n) %>% \n  \n  # add info from stimlist\n  left_join(overall_stimlist %>% filter(ID==1)) %>%  # change ID! = for-loop\n  \n  # determine whether shock or not (can also use 1 and 0)\n  rowwise() %>%   # this is crucial! otherwise it will always be the same value\n  mutate(\n    trial_type = ifelse(CS_type %in% c(\"threat\", \"safety\", \"amb1\", \"amb2\"), \"sc\", \"mc\"),\n    \n    shock = case_when(\n      CS_type == \"threat\" ~ \"shock\", \n      CS_type == \"safety\" ~ \"noshock\",\n      CS_type %in% c(\"amb1\", \"amb2\") ~ sample(c(\"shock\",\"noshock\"), 1, prob = c(.5,.5))))\n     # CS_type %in% c(\"amb1\", \"amb2\") ~ rbinom(1,1,.5)))\n```\n:::\n\n\nBtw: This will lead to shocks being delivered not exactly 50% of the time in the amb1/2 trials –\\> see above for other solution.\n\n## Multi-cue trials?\n\n**Task: Any ideas how we can do the same also for mc trials? (1 min.)**\n\n. . .\n\nFor the multi-cue trials, we could split the name of the stimuli to two columns and do similar things as above with both columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we start again with the trial_list, code from above\ntriallist_vp1 <- tibble(\n  trial = 1:length(trial_list),\n  block = 1,\n  type = trial_list # DIFFERENT name as in stimlist for join! (not neccessary!)\n) %>% \n  \n  separate_wider_delim(type, delim=\"-\", names=c(\"CS_type1\", \"CS_type2\"), cols_remove = FALSE, too_few = \"align_start\") %>% \n  # last argument leads to NAs in 2nd column for SC trials\n  \n   # add info from stimlist\n  left_join(., overall_stimlist %>% filter(ID==1), by = join_by(CS_type1 == CS_type)) %>%  # change ID! = for-loop\n  \n  # determine whether shock or not (can also use 1 and 0)\n  rowwise() %>% \n  mutate(\n    trial_type = ifelse(type %in% c(\"threat\", \"safety\", \"amb1\", \"amb2\"), \"sc\", \"mc\"), \n    \n    shock1 = case_when(\n      CS_type1 == \"threat\" ~ \"shock\", \n      CS_type1 == \"safety\" ~ \"noshock\",\n      CS_type1 %in% c(\"amb1\", \"amb2\") ~ sample(c(\"shock\",\"noshock\"), 1, prob = c(.5,.5))),\n    \n    shock2 = case_when(\n      CS_type2 == \"threat\" ~ \"shock\", \n      CS_type2 == \"safety\" ~ \"noshock\",\n      CS_type2 %in% c(\"amb1\", \"amb2\") ~ sample(c(\"shock\",\"noshock\"), 1)),\n    shock = coalesce(shock2, shock1)) %>% # uses \"shock2\" unless there's NA, then shock1\n    \n    # also add shape and color for 2nd stimulus in MC trials - could use ifelse(), case_when() or join again\n    left_join(overall_stimlist %>% \n                filter(ID==1) %>% \n                select(stim_shape, stim_col, combi, CS_type), \n              by = join_by(CS_type2 == CS_type), # now pick CS_type2\n              suffix = c(\"\", \"2\"))  # adds a 2 for the new columns added \n```\n:::\n\n\n## More stimuli!\n\nIn addition, Ecem wants to show 2 more stimuli in the multi-cue trials: The other combinations of shapes and colors, e.g. shape1 with color2 and shape2 with color1. We can easily add this to the dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriallist_vp1 <- triallist_vp1 %>% \n  # mutate(stim_shape3 = ifelse(trial_type == \"sc\", NA, stim_shape),  # only fill in if MC trial\n  #        stim_col3 = stim_col2,\n  #        stim_shape4 = stim_shape2,\n  #        stim_col4 = ifelse(trial_type == \"sc\", NA, stim_col))\n  mutate(combi3 = ifelse(trial_type == \"sc\", NA, str_c(stim_shape, stim_col2, sep = \"_\")),\n         combi4 = ifelse(trial_type == \"sc\", NA, str_c(stim_shape2, stim_col, sep = \"_\")))\n```\n:::\n\n\n. . .\n\nEcem also wants to shuffle the four stimuli and show them in a different order on the other side of the screen. Again, there is probably a number of different solutions!\n\nHere, we shuffle the stimulus names from all four \"combi\"-columns. Because `sample()` gives out 4 values then but we can only save one within mutate(), we `paste`/concatenate/`str_c()` them and separate that string in the next step into four columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriallist_vp1 <- triallist_vp1 %>% \n  mutate(allcombisshuffled = str_c(sample(c(combi, combi2, combi3, combi4)), collapse = \";\")) %>% \n  separate_wider_delim(allcombisshuffled, delim = \";\", names = c(\"combi5\", \"combi6\", \"combi7\", \"combi8\"))\n```\n:::\n\n\n## Bring it all together for all participants\n\nWe can use the `overall_stimlist` we already made for all (four) participants. We could do the same without the for-loop (just have another column for participant and more rows), but we will use a for loop for now so you can practice it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1-2|4|5-11|13-17|19-21|23-28|30-41|43|45-46|47-48|50-51|53-54\"}\nntrials <- 100\nnsubjects <- 4\n\nfor (s in 1:nsubjects) {\n  triallist <- tibble(\n    trial = 1:ntrials,\n    block = 1,\n    type = sample(c( \n      rep(c(\"threat\",\"safety\",\"amb1\",\"amb2\"), 15),\n      rep(c(\"threat-amb1\",\"threat-amb2\",\"safety-amb1\",\"safety-amb2\"), 10)))\n  ) %>% \n    \n    separate_wider_delim(type, \n                         delim=\"-\", \n                         names=c(\"CS_type1\", \"CS_type2\"), \n                         cols_remove = FALSE, \n                         too_few = \"align_start\") %>% # last argument leads to NAs in 2nd column for SC trials\n    \n    # add info from stimlist\n    left_join(overall_stimlist %>% filter(ID==s), # change ID! = for-loop\n              by = join_by(CS_type1 == CS_type)) %>%  \n    \n     # also add shape and color for 2nd stimulus in MC trials - could use ifelse(), case_when() or join again\n    left_join(overall_stimlist %>% \n                filter(ID==s) %>% \n                select(stim_shape, stim_col, combi, CS_type), \n              by = join_by(CS_type2 == CS_type), # now pick CS_type2\n              suffix = c(\"\", \"2\")) %>%  # adds a 2 for the new columns added \n    \n    # determine whether shock or not (can also use 1 and 0)\n    rowwise() %>% \n    mutate(\n      trial_type = ifelse(type %in% c(\"threat\", \"safety\", \"amb1\", \"amb2\"), \"sc\", \"mc\"),\n      shock1 = case_when(\n        CS_type1 == \"threat\" ~ \"shock\", \n        CS_type1 == \"safety\" ~ \"noshock\",\n        CS_type1 %in% c(\"amb1\", \"amb2\") ~ sample(c(\"shock\",\"noshock\"), 1, prob = c(.5,.5))),\n      shock2 = case_when(\n        CS_type2 == \"threat\" ~ \"shock\", \n        CS_type2 == \"safety\" ~ \"noshock\",\n        CS_type2 %in% c(\"amb1\", \"amb2\") ~ sample(c(\"shock\",\"noshock\"), 1)),\n      \n      shock = coalesce(shock2, shock1)) %>% # uses \"shock2\" unless there's NA, then shock1\n    \n    mutate(combi3 = ifelse(trial_type == \"mc\", str_c(stim_shape, stim_col2, sep = \"_\"), NA),\n           combi4 = ifelse(trial_type == \"mc\", str_c(stim_shape2, stim_col, sep = \"_\"), NA),\n           allcombisshuffled = str_c(sample(c(combi, combi2, combi3, combi4)), collapse = \";\")) %>% \n    separate_wider_delim(allcombisshuffled, delim = \";\", names = c(\"combi5\", \"combi6\", \"combi7\", \"combi8\")) %>% \n    \n    # clean up (remove unnecessary columns, reorder)\n    select(ID, block, trial, trial_type, shock, CS_type = type, CS_type1, CS_type2, combi, combi2, combi3, combi4, combi5, combi6, combi7, combi8) \n    \n    # save for each participant\n    write_csv(triallist, paste0(\"Triallist_\", as.character(s), \".csv\"))\n  \n}\n```\n:::\n\n\n## Block 2\n\nThe last step for Ecem's design would be to generate the stimuli for the second block!\n\nIn this block, the threat and safety stimuli should become ambiguous stimuli, and amb1 and amb2 should become threat and safety (though it should be random which becomes which - or does it even matter? The participants don't know which ambiguous stimulus is amb1?).\n\nWe'll do the easy solution for now and simply swap threat with amb1, and safety with amb2. We'll go back to the original stimulus list to add this information:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverall_stimlist <- overall_stimlist %>% \n  mutate(CS_type_block2 = case_when(\n    CS_type == \"threat\" ~ \"amb1\",\n    CS_type == \"safety\" ~ \"amb2\",\n    CS_type == \"amb1\" ~ \"threat\",\n    CS_type == \"amb2\" ~ \"safety\"))\n```\n:::\n\n\nWe can bring this in a longer format, so that we can simply run the code (with minor adjustments) from above for all trials (but we could also run it twice and change the column from CS_type to CS_type_block2):\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverall_stimlist2 <- overall_stimlist %>% \n  pivot_longer(cols = starts_with(\"CS_type\"),\n               names_to = \"block\")\n```\n:::\n\n\n## Thanks!\n\nNo R club next week! (Carnival)\n\nHomework: Please have a look at the [rest of last week's presentation](https://hillea.github.io/rclubwue/Slides/W2b_DataWranglingR.html#/data-wrangling-3) and/or [chapter 6 of Fundamentals of Quantitative Analysis](https://psyteachr.github.io/quant-fun-v2/data-wrangling-3.html)!\\\n(We've covered a lot of it today, but it will help you understand joins and bringing data in long format etc. better!)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}