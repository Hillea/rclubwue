{
  "hash": "4b05fd8ea3c593b9e5871111d514b08b",
  "result": {
    "markdown": "---\ntitle: \"Wrangling Physio Markers\"\nsubtitle: |\n   | R Coding Club \n   | RTG 2660\nauthor: \"Dr. Lea Hildebrandt\"\ndate: 2024/02/14\ndescription: \"Defining phases and calculating things\"\nformat: \n  revealjs:\n    smaller: true\n    scrollable: true\n    slide-number: true\n    theme: simple\n    chalkboard: true\neditor: visual\nfrom: markdown+emoji\n---\n\n\n## Warm up?\n\nDid anyone bring a problem?\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n<style type=\"text/css\">\ncode.sourceCode {   font-size: 1.4em; }   \ndiv.cell-output-stdout {   font-size: 1.4em; }\n</style>\n:::\n\n\n## Problem Definition (1)\n\nYou have collected data, let's say Skin Conductance, during your experiment with several trials. In each participant's file, you thus have (at least) two columns: `SC` and `markers`, and probably `time`. Markers are numbers that denote certain events, such as the start of a phase or trial.\n\nThe data set could thus like this:\n\n| time | SC    | markers |\n|------|-------|---------|\n| 100  | 1.964 | 10      |\n| 200  | 2.004 | 0       |\n| 300  | 2.365 | 0       |\n| 400  | 2.201 | 5       |\n| 500  | 2.589 | 0       |\n| 600  | 2.662 | 0       |\n| 700  | 2.803 | 0       |\n| 800  | 2.754 | 0       |\n| 900  | 2.839 | 6       |\n| 1000 | 2.915 | 0       |\n\nLet's say 10 is the onset of the block, 5 the onset of the trial, and 6 the end of the trial or onset of the next phase.\n\nHow can we make sure we know which rows belong to which phase of the experiment, e.g. which data points we need to use if we want to calculate something for the trial starting with marker 5?\n\n**In small groups, brainstorm how you solve this!\\\n**(Break it down in little steps, pseudo-code)\n\n## Francesco's Data\n\nWe will use Francesco's data of his pilot participant 2 (*VP02.txt*) to solve this problem.\n\nHowever, this brings us to a different problem, because his data are in a weird format! The actual data only start after a number of rows with channel information...\n\n**How can we read in the data well??**\n\n![Francesco's data](images/Francescos.PNG)\n\n## One possible solution - reading in data\n\nFirst one to finish: Share solution! :grin:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  library(tidyverse)\n  VPcode <- \"VP02\"\n  \n  # find the onset of the data to skip long header (may vary per file, but starts with min or CH1)\n  findstart <-  read_lines(paste0(\"Data/\", paste0(VPcode,\".txt\")), n_max = 50)\n  header_idx <- str_which(findstart, \"^min|CH1\")\n  \n  # read in data from the next line and the header from that line\n  header <- read_delim(paste0(\"Data/\", paste0(VPcode,\".txt\")), delim = \"\\t\", skip = header_idx-1, n_max = 1)\n  \n  phy_data <- read_delim(paste0(\"Data/\", paste0(VPcode,\".txt\")), delim = \"\\t\", skip = header_idx)\n  \n  names(phy_data) <- names(header)\n  \n  head(phy_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 11\n    CH13   CH14  CH28  CH29  CH30  CH31  CH32  CH33  CH34  CH35 ...11\n   <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <lgl>\n1 0.0258 0.0674     0     0     0     0     0     0     0     0 NA   \n2 0.0288 0.0681     0     0     0     0     0     0     0     0 NA   \n3 0.0258 0.0681     0     0     0     0     0     0     0     0 NA   \n4 0.0273 0.0652     0     0     0     0     0     0     0     0 NA   \n5 0.0258 0.0627     0     0     0     0     0     0     0     0 NA   \n6 0.0212 0.0581     0     0     0     0     0     0     0     0 NA   \n```\n:::\n:::\n\n\n## Get the correct markers\n\nRemember a few weeks ago when we talked about how to transform the binary values in the eight channels to markers? Do that now!\n\nReminder:\\\nChannel 1 = value 1\\\nChannel 2 = 2\\\nChannel 3 = 4\\\nChannel 4 = 8\\\nChannel 5 = 16\\\nChannel 6 = 32\\\nChannel 7 = 64\\\nChannel 8 = 128.\\\n\\\nSo if there's a signal (which will have the value \"5\") in channel 1, 3, and 6, the resulting marker should be 1+4+32=37.\n\n**Implement this now in R code!\\\nAlso check whether it worked correctly.**\n\n## Possible solution - markers\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphy_data <- phy_data %>% \n    \n    # rename channels to more sensible names\n    rename(#time = min,  # doesn't exist in all files\n      SC = CH13,\n      HR = CH14,  # is this HR?\n      one = CH28,\n      two = CH29,\n      four = CH30,\n      eight = CH31,\n      sixteen = CH32,\n      thirtytwo = CH33,\n      sixtyfour = CH34,\n      hundredtwentyeight = CH35) %>% \n    \n    # get time from start (make it based on sampling rate of 2000Hz --> 0.5msec between samples) and triggers\n    mutate(# combine digital input channels from 8-bit binary to decimal\n           marker = (1*one + 2*two + 4*four + 8*eight + 16*sixteen + 32*thirtytwo + 64*sixtyfour + 128*hundredtwentyeight) / 5)\n\n# check whether markers were calculated correctly\nunique(phy_data$marker)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   0 128  11   4   1  16  22  33  90   7  32   8  44  55  64   2  66\n```\n:::\n\n```{.r .cell-code}\nidx_first_marker <- which(phy_data$marker != 0)[c(1,1000,2000)]\nphy_data[idx_first_marker,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 12\n     SC      HR   one   two  four eight sixteen thirtytwo sixtyfour\n  <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>     <dbl>     <dbl>\n1  3.63  0.0221     0     0     0     0       0         0         0\n2  9.56  0.0584     5     0     0     0       0         0         0\n3 11.3  -0.0713     0     5     0     5       5         0         5\n# ℹ 3 more variables: hundredtwentyeight <dbl>, ...11 <lgl>, marker <dbl>\n```\n:::\n:::\n\n\n## Get trial onsets\n\nFor Francesco's data, the markers 90 (CS+) and 7 (CS-) are of interest, as they denote the trial onsets.\n\n**First check out whether and how often these markers exist.**\n\nThe markers are shown for \\~55 samples each. **How can we get the onset only (i.e. only one sample/row)?**\n\nHow many trials do we have?\n\n## Possible solutions - get onsets\n\nWho has a good solution?\n\n. . .\n\nOne option is to get the streaks of the marker column using the `rle()` function in base R (there's also an even handier `rleid()` function in the data.table package...).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstreaks <- rle(phy_data$marker) # gives two lists: lenght and value, you'd still have to add the lengths up again \n```\n:::\n\n\nOr you could simply get the difference in marker value to previous sample. All values in a streak will be 0, every onset will be different from 0. We can then filter either by the value of this difference (e.g. -7, but we don't know exactly!) or by != 0 + marker == 7.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphy_data <- phy_data %>% \n  mutate(diffs = marker - lag(marker),         \n         onsets7 = (diffs != 0) & (marker == 7),          \n         onsets90 = (diffs != 0) & (marker == 90),          \n         # or we combine it in one column:          \n         onsets = ifelse((diffs != 0) & (marker != 0), marker, NA)) \n```\n:::\n\n\n## Time column\n\nThere is no time column! It might make sense to make an artificial time column (if we know the sampling rate, this would be possible) or we can simply add the rownumber as a separate column.\n\n**How would you do this?**\n\n## Solution - time\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphy_data <- phy_data %>% \n  mutate(time = 1:nrow(phy_data),\n         time2 = 1:n(),\n         time3 = row_number()) %>% \n  rownames_to_column(\"time4\")\n```\n:::\n\n\n## Get the offset markers\n\nIn Francesco's case, there is not necessarily an \"end-marker\" (or the onset of the next phase), but we know that each trial is 8 sec. long. It might make sense to add this offset to the data.\n\n**Come up with a way to add offset markers to the dara 8 sec after the 7 or 90 onsets!**\n\n## Possible solution - offset markers\n\nPlease share ideas!\n\n. . .\n\nI would probably simply get the indeces of the markers, add the correct number of samples - based on new time column (if it is really time) or sampling rate - to these, and add markers to these new indices (but there might be a tidyverse-isher way as well!):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# helpers\nsampling_rate <- 2000\neight_sec <- sampling_rate * 8\n\nonsets790 <- which(phy_data$onsets %in% c(7,90))\noffsets790 <- onsets790 + eight_sec\n\nphy_data$onsets[offsets790] <- 150\n\n\n# check wether correct\ntest <- filter(phy_data, !is.na(onsets) & onsets != 0) %>% select(onsets)\n```\n:::\n\n\n## Get the correct phases\n\nBack to the original problem: We want to get the correct \"phases\" of the experiment to do calculations (e.g. calculate the mean within the phase) with, e.g. the trials.\n\n**Calculate the mean SC for each trial (starting with either 7 or 90).** \\\nYou might have to take different intermediate steps, depending on your solution!\n\n## Possible solutions - get trials\n\nShow all your solutions!\n\n. . .\n\nThere are a number of different ways to achieve this. You could use a for-loop to loop through all onsets, get the index and the index of the offset marker and calculate the mean of that period:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- tibble(means = rep(NA, length(onsets790)),\n                marker = rep(NA, length(onsets790)))\n\nfor (i in seq(onsets790)) {\n  means$means[i] <- mean(phy_data$SC[onsets790[i]]:phy_data$SC[offsets790[i]]) \n  means$marker[i] <- phy_data$marker[onsets790[i]]\n}\n\n#possibly add other info like what kind of marker/trial etc.\n```\n:::\n\n\nAnother (tidyverse) solution would be to get the trial number, fill in the onsets (so that all samples until the next marker are filled in with e.g. 7), group_by the marker number and trial, and summarize:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans2 <- phy_data %>% \n  # use cumsum() to get a trial number\n  mutate(trial_onset = ifelse(is.na(onsets), 0, 1),\n           trial = cumsum(trial_onset)) %>% \n  fill(onsets) %>% \n  group_by(trial, onsets) %>% \n  summarise(means = mean(SC)) %>% \n  # possibly filter to only keep 7 and 90\n  filter(onsets %in% c(90,7))\n```\n:::\n\n\n## Extra task: Get min and max within window\n\nFor the SC data, we don't only need the mean, but rather the local minimum and maximum 1-5 sec. after stimulus onset (or rather, the maximum after the minimum, but let's start with overall min and max).\n\n**Try to find the min. and max. in the 1-5 sec. window!**\n\n## Possible solutions - min and max\n\nAny ideas?\n\n. . .\n\nSimilar to above!\n\n## Thanks!\n\nNext week: Data Viz (really!)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}